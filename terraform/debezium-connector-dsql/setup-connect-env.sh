#!/usr/bin/env bash
set -euo pipefail

HERE="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$HERE/../.." && pwd)"
TF_DIR="$REPO_ROOT/terraform"

OUT_FILE="$HERE/connect.env"

echo "Generating $OUT_FILE from Terraform outputs (DSQL) + placeholders (Confluent)..."

# Prefer reading Confluent Cloud credentials from repo-root .env (gitignored)
# Expected keys (compatible with env-examples/k6.env.example):
# - KAFKA_BOOTSTRAP_SERVERS
# - KAFKA_API_KEY
# - KAFKA_API_SECRET
ENV_FILE_ROOT="$REPO_ROOT/.env"

read_env_kv() {
  # Usage: read_env_kv <file> <KEY>
  # Returns value to stdout (strips optional leading 'export ' and surrounding quotes)
  local file="$1"
  local key="$2"
  local line
  line="$(grep -E "^(export[[:space:]]+)?${key}=" "$file" 2>/dev/null | tail -n 1 || true)"
  if [ -z "$line" ]; then
    return 1
  fi
  line="${line#export }"
  line="${line#${key}=}"
  # Strip surrounding quotes if present
  if [[ "$line" =~ ^\".*\"$ ]]; then
    line="${line:1:${#line}-2}"
  elif [[ "$line" =~ ^\'.*\'$ ]]; then
    line="${line:1:${#line}-2}"
  fi
  printf "%s" "$line"
  return 0
}

CC_BOOTSTRAP_FROM_DOTENV=""
CC_KEY_FROM_DOTENV=""
CC_SECRET_FROM_DOTENV=""
if [ -f "$ENV_FILE_ROOT" ]; then
  CC_BOOTSTRAP_FROM_DOTENV="$(read_env_kv "$ENV_FILE_ROOT" "KAFKA_BOOTSTRAP_SERVERS" || true)"
  CC_KEY_FROM_DOTENV="$(read_env_kv "$ENV_FILE_ROOT" "KAFKA_API_KEY" || true)"
  CC_SECRET_FROM_DOTENV="$(read_env_kv "$ENV_FILE_ROOT" "KAFKA_API_SECRET" || true)"
fi

if [ ! -d "$TF_DIR" ]; then
  echo "Terraform dir not found: $TF_DIR"
  exit 1
fi

cd "$TF_DIR"

# Use DSQL host format (not VPC endpoint) for correct SNI in SSL handshake
DSQL_ENDPOINT_PRIMARY="$(terraform output -raw aurora_dsql_host 2>/dev/null || terraform output -raw aurora_dsql_endpoint 2>/dev/null || true)"
DSQL_DATABASE_NAME="$(terraform output -raw aurora_dsql_database_name 2>/dev/null || true)"
IAM_USER="$(terraform output -raw iam_database_user 2>/dev/null || true)"

# Fallbacks (repo defaults)
DSQL_DATABASE_NAME="${DSQL_DATABASE_NAME:-car_entities}"
IAM_USER="${IAM_USER:-dsql_iam_user}"

if [ -z "$DSQL_ENDPOINT_PRIMARY" ]; then
  echo "Could not read terraform output aurora_dsql_host or aurora_dsql_endpoint. Did you run terraform apply?"
  exit 1
fi

cat > "$OUT_FILE" <<EOF
# Generated by terraform/debezium-connector-dsql/setup-connect-env.sh
# WARNING: contains Confluent Cloud credentials. This file is gitignored.

# Confluent Cloud Kafka
CC_BOOTSTRAP_SERVERS=${CC_BOOTSTRAP_FROM_DOTENV:-pkc-xxxxx.us-east-1.aws.confluent.cloud:9092}
CC_KAFKA_API_KEY=${CC_KEY_FROM_DOTENV:-REPLACE_ME}
CC_KAFKA_API_SECRET=${CC_SECRET_FROM_DOTENV:-REPLACE_ME}

# Kafka Connect worker topics (will be created if missing)
CONNECT_GROUP_ID=dsql-connect-ec2
CONNECT_CONFIG_STORAGE_TOPIC=_dsql_connect_configs
CONNECT_OFFSET_STORAGE_TOPIC=_dsql_connect_offsets
CONNECT_STATUS_STORAGE_TOPIC=_dsql_connect_status

# DSQL / connector settings
DSQL_ENDPOINT_PRIMARY=$DSQL_ENDPOINT_PRIMARY
DSQL_IAM_USERNAME=$IAM_USER
DSQL_DATABASE_NAME=$DSQL_DATABASE_NAME
DSQL_TABLE=event_headers

# Output topic routing
TOPIC_PREFIX=dsql-cdc
ROUTED_TOPIC=raw-event-headers

# Connector name
CONNECTOR_NAME=dsql-cdc-source-event-headers
EOF

chmod 600 "$OUT_FILE" || true
echo "âœ“ Wrote $OUT_FILE"
echo ""
echo "Next: edit these 3 fields in $OUT_FILE:"
echo "  - CC_BOOTSTRAP_SERVERS"
echo "  - CC_KAFKA_API_KEY"
echo "  - CC_KAFKA_API_SECRET"

if [ -f "$ENV_FILE_ROOT" ]; then
  echo ""
  echo "Note: values were auto-filled from $ENV_FILE_ROOT when present:"
  echo "  - KAFKA_BOOTSTRAP_SERVERS -> CC_BOOTSTRAP_SERVERS"
  echo "  - KAFKA_API_KEY -> CC_KAFKA_API_KEY"
  echo "  - KAFKA_API_SECRET -> CC_KAFKA_API_SECRET"
fi
